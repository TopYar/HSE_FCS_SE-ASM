;--------------------------------------------------------------------------
macro IterationOfStringSymbols {
;--------------------------------------------------------------------------
; ѕроходит по каждому символы в ESI. ѕровер€ет, гласна€ ли буква. «аписывает символ в EDI
         IterateStringSymbols:
                mov     [tmpStack], esp             ; сохран€ем стек вместе в адресом возврата
                stdcall strlen, esi                 ; подсчитываем длину строки источника
                mov     ecx, eax                    ; установливаем счетчик цикла на EAX раз (длина строки)
                _loop:
                        push    ecx                 ; сохран€ем счетчик в стек

                        lodsb                       ; загружаем символ [esi] (символ, на который указывает esi) в регистр AL: { AL = [esi]; esi += 1; }
                        mov     [ediTmp], edi       ; сохран€ем адрес приемника
                        call    CheckForSyllable    ; провер€ем символ AL на то, €вл€етс€ ли гласной буквой

                        pop     ecx                 ; достаем счетчик из стека
                        LOOP    _loop
                mov esp, [tmpStack]                 ; возвращаем адрес возврата в стек
                ret
}

;--------------------------------------------------------------------------
macro CheckSymbolForBeingSyllable {
;--------------------------------------------------------------------------
; ѕровер€ет, €вл€етс€ ли регистр AL гласной или нет. ѕосле этого записывает символ в EDI
         CheckForSyllable:
                mov [tmpStack2], esp            ; сохран€ем стек вместе в адресом возврата

                mov   edi, syllStr              ; указываем адрес приемника как строку с прописными гласными буквами
                mov   ecx, 6                    ; устанавливаем максимум 6 итераций, т.к. всего 6 гласных букв
                repne scas byte [edi]           ; while ( ecx > 0 && syllStr[i] != AL) { ecx -= 1; edi += 1}
                je    ToUpper                   ; если символ гласной нашелс€ в строке, устанавливаетс€ флаг ZF = 1 и происходит прыжок je
                jmp   EndChecking               ; иначе просто заканчиваем проверку

         ToUpper:
                sub   al, 32                    ; вычитаем 32 из кода ASCII прописной гласной (наш AL из [esi]) и получаем заглавную гласную
                inc   [numChg]                  ; увеличиваем количество затронутых символов
                jmp   EndChecking               ; заканчиваем проверку

         EndChecking:
                mov   edi, [ediTmp]             ; возвращаем наш регистр-приемник (str2)
                stosb                           ; устанавливаем AL в байт, на который указывает edi (регистр-приемник): {[edi] = AL; edi += 1; }
                mov   esp, [tmpStack2]          ; возвращаем адрес возврата в стек
                ret
}

;--------------------------------------------------------------------------
macro StrlenProcedure {
;--------------------------------------------------------------------------
; ѕроцедура вычислени€ длины строки из стека
         strlen:
                mov     [ediTmp], edi  ; сохран€ем предыдущий регистр EDI
                mov     edi, [esp+4]   ; используем str как аргумент из стэка
                mov     ecx, -1        ; ecx < 0, чтобы цикл не закончилс€ раньше времени
                xor     al, al         ; последний элемент строки - 0
                cld                    ; обнул€ем флаг DF, т.к. пр€мой проход по строке
                repne   scasb          ; while(str[edi] != al) {edi++; ecx--;}
                neg     ecx
                sub     ecx, 1         ; ecx = length(str)-1; count \0 symbol
                mov     eax, ecx
                mov     edi, [ediTmp]  ; возвращаем предыдуший EDI назад
                ret
}